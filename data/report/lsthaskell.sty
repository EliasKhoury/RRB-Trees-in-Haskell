% lstlisting Haskell style (inspired from a file of Assia Mahboubi)
%
\lstdefinelanguage{Haskell}{ 
%
% Anything betweeen $ becomes LaTeX math mode
breaklines=true,
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
mathescape=true,
%
% Comments may or not include Latex commands
texcl=false, 
emph= {[1]
	FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOf,asin,
	asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
	const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
	dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
	error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
	fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
	fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
	interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
	isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
	last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
	maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
	or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
	quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
	readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
	reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
	showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
	sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
	toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
	unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse
},
emphstyle={[1]\color{dkblue}},
emph=
{[2]
	Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String,
	Word8,InPacket
},
emphstyle={[2]\color{dkgreen}},
emph=
{[3]
	case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
	module,of,primitive,then,type,where
},
emphstyle={[3]\color{dkviolet}\textbf},
emph=
{[4]
	quot,rem,div,mod,elem,notElem,seq
},
emphstyle={[4]\color{dkviolet}\textbf},
emph=
{[4]
	Tree,Node,Leaf
},
emphstyle={[4]\color{dkgreen}\textbf},
emph=
{[5]
	EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
},emphstyle={[5]\color{dkred}\textbf},
%
%morekeywords=[1]{class, instance},
%
%morekeywords=[2]{where},
%
%morekeywords=[3]{Maybe},
%
%morekeywords=[4]{main},
%
%morekeywords=[6]{do, last, first, try, idtac, repeat},
%
% Comments delimiters, we do turn this off for the manual
morecomment=[s]{(*}{*)},
%
% Spaces are not displayed as a special character
showstringspaces=false,
%
% String delimiters
morestring=[b]",
morestring=[d]Â’,
%
% Size of tabulations
tabsize=3,
%
% Enables ASCII chars 128 to 255
extendedchars=false,
%
% Case sensitivity
sensitive=true,
%
% Automatic breaking of long lines
%
% Default style fors listings
basicstyle=\footnotesize\ttfamily,
%
% Position of captions is bottom
captionpos=b,
%
% flexible columns
columns=[l]flexible,
%
% Style for (listings') identifiers
identifierstyle={\ttfamily\color{black}},
% Style for declaration keywords
keywordstyle=[1]{\ttfamily\color{dkviolet}},
% Style for gallina keywords
keywordstyle=[2]{\ttfamily\color{dkgreen}},
% Style for sorts keywords
keywordstyle=[3]{\ttfamily\color{ltblue}},
% Style for tactics keywords
keywordstyle=[4]{\ttfamily\color{dkblue}},
% Style for terminators keywords
keywordstyle=[5]{\ttfamily\color{dkred}},
%Style for iterators
%keywordstyle=[6]{\ttfamily\color{dkpink}},
% Style for strings
stringstyle=\ttfamily,
% Style for comments
commentstyle={\ttfamily\color{dkgreen}},
%
%moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
literate=
    {->}{{$\rightarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\\dollar}{{$\$$\;}}1
%
}[keywords,comments,strings]

\lstnewenvironment{haskell}{\lstset{language=Haskell}}{}

% pour inliner dans le texte
\def\hasqel{\lstinline[language=Haskell, basicstyle=\small]}
% pour inliner dans les tableaux / displaymath...
\def\haskels{\lstinline[language=Haskell, basicstyle=\scriptsize]}

%%% Local Variables: 
%%% mode: latex
%%% Local IspellDict: british
%%% TeX-master: "main.tex"
%%% End: 
